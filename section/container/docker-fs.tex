\chapter{Running Docker on FutureSystems}\label{S:docker-fg}

\FILENAME

\section{Overview}\label{overview}

This documentation introduces how to run Docker container on
FutureSystems. Currently we have deployed Docker swarm on Echo.

\section{Getting Access}\label{getting-access}

You will need an account on FutureSystems. To verify, try to see if you
can log into india.futuresystems.org. You need to be a member of a valid
FutureSystems project, and had submitted an ssh public key via the
FutureSystems portal.

If your access to the india host has been verified, try to login to the
docker swarm head node with the same username and key:

\begin{verbatim}
ssh FS_USER@149.165.150.76
\end{verbatim}

\textbf{NOTE: If you have access to india but not the docker swarm
system, your project may not have been authorized to access the docker
swarm cluster. Send a ticket to FutureSystems ticket system to request
this.}

Once logged in to the docker swarm head node, try to run:

\begin{verbatim}
docker run hello-world
\end{verbatim}

to verify `docker run' works.

\section{Creating a service and deploy to the swarm
cluster}\label{creating-a-service-and-deploy-to-the-swarm-cluster}

While `docker run' can start a container and you may even attach to its
console, the recommended way to use a docker swarm cluster is to create
a service and have it run on the swarm cluster. The service will be
scheduled to one or many number of the nodes of the swarm cluster, based
on the configuration. It's also easy to scale up the service when more
swarm nodes are available. Docker swarm really makes it easier for
service/application developers to focus on the functionality development
but not worrying about how and where to bind the service to some
resources/server. The deployment, access, and scaling up/down when
necessary, are all managed transparently. Thus achieving the new
paradigm of `serverless computing'.

As an example, the following command creates a service and deploy it to
the swarm cluster:

\begin{quote}
docker service create --name notebook\_test -p 9001:8888
jupyter/datascience-notebook start-notebook.sh
--NotebookApp.password=NOTEBOOK\_PASS\_HASH
\end{quote}

The NOTEBOOK\_PASS\_HASH can be generated in python:

\begin{verbatim}
>>> import IPython
>>> IPython.lib.passwd("YOUR_SELECTED_PASSWROD")
'sha1:52679cadb4c9:6762e266af44f86f3d170ca1......'
\end{verbatim}

So pass through the string starting with 'sha1:......'.

The command pulls a published image from docker cloud, starts a container and
runs a script to start the service inside the container with necessary
parameters. The option ``-p 9001:8888'' maps the service port inside the
container (8888) to an external port of the cluster node (9001) so the
service could be accessed from the Internet. In this example, you can
then visit the URL:

\begin{quote}
\url{http://149.165.150.76:9001}
\end{quote}

to access the Jupyter notebook. Using the specified password when you
create the service to login.

Please note the service will be dynamically deployed to a container
instance, which would be allocated to a swarm node based on the
allocation policy. Docker makes this process transparent to the user and
even created mesh routing so you can access the service using the IP
address of the management head node of the swarm cluster, no matter
which actual physical node the service was deployed to.

This also implies that the external port number used has to be free at
the time when the service was created.

Some useful related commands:


\begin{verbatim}
docker service ls
\end{verbatim}

lists the currently running services.

\begin{verbatim}
docker service ps notebook_test
\end{verbatim}

lists the detailed info of the container where the service is running.

\begin{verbatim}
docker node ps NODE
\end{verbatim}

lists all the running containers of a node.

\begin{verbatim}
docker node ls
\end{verbatim}

lists all the nodes in the swarm cluster.

To stop the service and the container:

\begin{verbatim}
docker service rm noteboot_test
\end{verbatim}


\subsection{Create your own service}\label{create-your-own-service}

You can create your own service and run it. To do so, start from a base
image, e.g., a ubuntu image from the docker cloud. Then you could:

\begin{itemize}

\item Run a container from the image and attach to its console to develop
the service, and create a new image from the changed instance using
command `docker commit'.

\item Create a dockerfile, which has the step by step building process of
the service, and then build an image from it.

\end{itemize}

In reality, the first approach is probably useful when you are in the
phase of develop and debug your application/service. Once you have the
step by step instructions developped the latter approach is the
recommended way.

Publish the image to the docker cloud by following this documentation:

\begin{quote}
\url{https://docs.docker.com/docker-cloud/builds/push-images/}
\end{quote}

Please make sure no sensitive information is included in the image to
be published. Alternatively you could publish the image internally to
the swarm cluster.

\paragraph{Publish an image privately within the swarm cluster}
\label{publish-an-image-privately-within-the-swarm-cluster}

\TODO{Fugang: create image for distribution}

Once the image is published and available to the swarm cluster, you
could start a new service from the image similar to the Jupyter Notebook
example.

\subsection{Exercises}

\end{exercise}

Obtain an account on future systems.

\end{exercise}

\end{exercise}

Create a REST service with swagger codegen and run it on the echo cloud.

\end{exercise}
